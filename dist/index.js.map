{"version":3,"sources":["../src/config.ts","../src/extensions/fact-validation.ts","../src/extensions/utils.ts","../src/extensions/actions.ts","../src/alfafrens-client.ts","../src/api.ts","../src/memory.ts","../src/extensions/ai-interaction.ts","../src/extensions/tasks.ts","../../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/stringify.js","../../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/rng.js","../../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/native.js","../../../node_modules/.pnpm/uuid@11.1.0/node_modules/uuid/dist/esm/v4.js","../src/plugin.ts","../src/actions.ts","../src/extensions/index.ts","../src/extensions/ai-post.ts","../src/index.ts"],"sourcesContent":["import { IAgentRuntime, ModelClass } from \"@elizaos/core\";\nimport { AlfaFrensGenerationConfig } from \"./types\";\nimport { DEFAULT_POST_TEMPLATE, DEFAULT_RESPONSE_TEMPLATE, DEFAULT_EVALUATION_TEMPLATE } from \"./extensions/utils\";\n\n/**\n * load AlfaFrens configuration from runtime settings\n * @param runtime agent runtime\n * @returns loaded configuration\n */\nexport function loadAlfaFrensConfig(runtime: IAgentRuntime): AlfaFrensGenerationConfig {\n    const defaultModelClass = parseModelClass(runtime.getSetting(\"ALFAFRENS_MODEL_CLASS\"));\n\n    return {\n        evaluation: {\n            template: runtime.getSetting(\"ALFAFRENS_EVALUATION_TEMPLATE\") || \"\",\n            modelClass: parseModelClass(runtime.getSetting(\"ALFAFRENS_EVALUATION_MODEL_CLASS\")) || defaultModelClass\n        },\n        response: {\n            template: runtime.getSetting(\"ALFAFRENS_RESPONSE_TEMPLATE\") || \"\",\n            modelClass: parseModelClass(runtime.getSetting(\"ALFAFRENS_RESPONSE_MODEL_CLASS\")) || defaultModelClass\n        },\n        post: {\n            template: runtime.getSetting(\"ALFAFRENS_POST_TEMPLATE\") || \"\",\n            modelClass: parseModelClass(runtime.getSetting(\"ALFAFRENS_POST_MODEL_CLASS\")) || defaultModelClass\n        }\n    };\n}\n\n/**\n * Parse a model class string to ModelClass enum\n */\nfunction parseModelClass(modelClass?: string): ModelClass | undefined {\n    if (!modelClass) return undefined;\n\n    switch (modelClass.toUpperCase()) {\n        case \"SMALL\": return ModelClass.SMALL;\n        case \"MEDIUM\": return ModelClass.MEDIUM;\n        case \"LARGE\": return ModelClass.LARGE;\n        default: return undefined;\n    }\n} ","import { IAgentRuntime, Memory, elizaLogger, stringToUuid, generateText, ModelClass, Evaluator } from \"@elizaos/core\";\nimport { AlfaFrensMessage } from \"../types\";\n\nexport interface FactValidation {\n    confidence: number;\n    source: string;\n    timestamp: number;\n    contradictions: string[];\n    relationships?: Array<{\n        sourceEntityId: string;\n        targetEntityId: string;\n        tags: string[];\n        metadata?: {\n            interactions: number;\n        };\n    }>;\n}\n\nexport interface Contradiction {\n    fact: string;\n    existingFact: string;\n    confidence: number;\n    timestamp: number;\n}\n\nexport interface MemoryPriority {\n    importance: number;\n    lastAccessed: number;\n    accessCount: number;\n}\n\nexport const factEvaluator: Evaluator = {\n    name: \"FACT_VALIDATION\",\n    similes: [\"VALIDATE_FACTS\", \"CHECK_FACTS\", \"VERIFY_FACTS\"],\n    description: \"Validates and stores factual information from conversations, tracking relationships and contradictions\",\n    examples: [\n        {\n            context: \"User: I live in Seattle and work at Microsoft\",\n            messages: [\n                { user: \"user\", content: { text: \"I live in Seattle and work at Microsoft\" } }\n            ],\n            outcome: `{\n                \"facts\": [\n                    { \"claim\": \"User lives in Seattle\", \"type\": \"fact\", \"in_bio\": false, \"already_known\": false },\n                    { \"claim\": \"User works at Microsoft\", \"type\": \"fact\", \"in_bio\": false, \"already_known\": false }\n                ],\n                \"relationships\": [\n                    { \"sourceEntityId\": \"user-123\", \"targetEntityId\": \"microsoft\", \"tags\": [\"employment\"] }\n                ]\n            }`\n        }\n    ],\n    validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {\n        const messageCount = await runtime.messageManager.countMemories(message.roomId);\n        const reflectionCount = Math.ceil(runtime.getConversationLength() / 2);\n        return messageCount % reflectionCount === 0;\n    },\n    handler: async (runtime: IAgentRuntime, message: Memory) => {\n        const manager = new FactValidationManager(runtime);\n        const facts = await manager.extractFacts(message.content.text);\n        const results = [];\n\n        for (const fact of facts) {\n            const validation = await manager.validateFact(fact, {\n                id: message.id,\n                timestamp: new Date().toISOString(),\n                senderId: message.userId,\n                senderUsername: message.userId,\n                content: message.content.text\n            });\n            if (validation.confidence >= 0.7) {\n                await manager.storeFact(fact, validation);\n                results.push({\n                    fact,\n                    validation,\n                    stored: true\n                });\n            } else {\n                results.push({\n                    fact,\n                    validation,\n                    stored: false\n                });\n            }\n        }\n\n        return { results };\n    }\n};\n\nexport class FactValidationManager {\n    private runtime: IAgentRuntime;\n    private confidenceThreshold: number = 0.7;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n    }\n\n    async extractFacts(content: string): Promise<string[]> {\n        const prompt = `Extract factual statements from this text. Return ONLY a JSON array of strings.\n        Only include clear, factual statements, not opinions or subjective content.\n        The JSON array must be properly formatted with square brackets and quoted strings.\n        \n        Text: \"${content}\"\n        \n        Example format:\n        [\"Fact 1\", \"Fact 2\", \"Fact 3\"]\n        `;\n\n        try {\n            const result = await generateText({\n                runtime: this.runtime,\n                context: prompt,\n                modelClass: ModelClass.SMALL,\n            });\n\n            elizaLogger.debug(\"[FactValidation] Raw fact extraction result:\", result);\n\n            // Find JSON array in the response using regex\n            const jsonMatch = result.match(/\\[.*\\]/s);\n            if (!jsonMatch) {\n                elizaLogger.error(\"[FactValidation] No JSON array found in result:\", result);\n                return this.extractFactsFallback(content);\n            }\n\n            try {\n                const jsonStr = jsonMatch[0];\n                const facts = JSON.parse(jsonStr);\n\n                if (!Array.isArray(facts)) {\n                    elizaLogger.error(\"[FactValidation] Parsed result is not an array:\", facts);\n                    return this.extractFactsFallback(content);\n                }\n\n                // Filter out non-string items and empty strings\n                const validFacts = facts.filter(fact => typeof fact === 'string' && fact.trim().length > 0);\n                elizaLogger.debug(\"[FactValidation] Extracted facts:\", validFacts);\n                return validFacts;\n            } catch (parseError) {\n                elizaLogger.error(\"[FactValidation] Failed to parse JSON:\", parseError);\n                return this.extractFactsFallback(content);\n            }\n        } catch (error) {\n            elizaLogger.error(\"[FactValidation] Error during fact extraction:\", error);\n            return this.extractFactsFallback(content);\n        }\n    }\n\n    /**\n     * Fallback method for fact extraction that uses simple heuristics\n     * when LLM-based extraction fails\n     */\n    private extractFactsFallback(content: string): string[] {\n        elizaLogger.debug(\"[FactValidation] Using fallback fact extraction\");\n\n        // Simple rule-based extraction of potential factual statements\n        const sentences = content.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);\n        const potentialFacts = sentences.filter(sentence => {\n            // Filter for sentences that look like factual statements\n            // - Avoid questions\n            // - Avoid sentences with opinion words\n            // - Prefer sentences with dates, numbers, named entities\n            const isQuestion = sentence.includes('?') ||\n                sentence.toLowerCase().startsWith('what') ||\n                sentence.toLowerCase().startsWith('who') ||\n                sentence.toLowerCase().startsWith('when') ||\n                sentence.toLowerCase().startsWith('where') ||\n                sentence.toLowerCase().startsWith('why') ||\n                sentence.toLowerCase().startsWith('how');\n\n            const hasOpinionWords = /think|feel|believe|opinion|seem|appear|likely|possibly|maybe|perhaps/i.test(sentence);\n\n            const hasFactSignals = /in \\d{4}|\\d{4}|founded|created|established|launched|developed|built|designed|is a|was born|located|headquartered/i.test(sentence);\n\n            return !isQuestion && !hasOpinionWords && hasFactSignals;\n        });\n\n        elizaLogger.debug(\"[FactValidation] Fallback extracted facts:\", potentialFacts);\n        return potentialFacts;\n    }\n\n    async validateFact(fact: string, message: AlfaFrensMessage): Promise<FactValidation> {\n        const existingFacts = await this.getRelevantFacts(fact);\n        const contradictions = await this.detectContradictions(fact, existingFacts);\n        const confidence = this.calculateFactConfidence(fact, message, contradictions);\n        const relationships = await this.extractRelationships(fact, message);\n\n        return {\n            confidence,\n            source: message.senderId,\n            timestamp: Date.now(),\n            contradictions: contradictions.map(c => c.fact),\n            relationships\n        };\n    }\n\n    private async getRelevantFacts(fact: string): Promise<Memory[]> {\n        try {\n            const memories = await this.runtime.messageManager.getMemories({\n                roomId: this.runtime.agentId,\n                count: 100\n            });\n\n            return memories.filter(memory =>\n                this.calculateSemanticSimilarity(fact, memory.content.text) > 0.5\n            );\n        } catch (error) {\n            elizaLogger.error(\"[FactValidation] Failed to get relevant facts:\", error);\n            return [];\n        }\n    }\n\n    private async detectContradictions(fact: string, existingFacts: Memory[]): Promise<Contradiction[]> {\n        const contradictions: Contradiction[] = [];\n\n        for (const existingFact of existingFacts) {\n            const similarity = this.calculateSemanticSimilarity(fact, existingFact.content.text);\n            if (similarity > 0.8) {\n                const contradiction = await this.analyzeContradiction(fact, existingFact.content.text);\n                if (contradiction) {\n                    contradictions.push({\n                        fact,\n                        existingFact: existingFact.content.text,\n                        confidence: contradiction.confidence,\n                        timestamp: Date.now()\n                    });\n                }\n            }\n        }\n\n        return contradictions;\n    }\n\n    private async analyzeContradiction(fact1: string, fact2: string): Promise<{ confidence: number } | null> {\n        const prompt = `Analyze if these two facts contradict each other:\n        Fact 1: ${fact1}\n        Fact 2: ${fact2}\n        \n        Return a JSON object with:\n        {\n            \"contradicts\": boolean,\n            \"confidence\": number (0-1),\n            \"explanation\": string\n        }`;\n\n        try {\n            const result = await generateText({\n                runtime: this.runtime,\n                context: prompt,\n                modelClass: ModelClass.SMALL,\n            });\n\n            const analysis = JSON.parse(result);\n            if (analysis.contradicts && analysis.confidence > 0.7) {\n                return { confidence: analysis.confidence };\n            }\n        } catch (error) {\n            elizaLogger.error(\"[FactValidation] Failed to analyze contradiction:\", error);\n        }\n\n        return null;\n    }\n\n    private async extractRelationships(fact: string, message: AlfaFrensMessage): Promise<FactValidation['relationships']> {\n        const prompt = `Extract relationships from this fact. Return them as a JSON array of objects.\n        Each object should have:\n        {\n            \"sourceEntityId\": string (the subject),\n            \"targetEntityId\": string (the object),\n            \"tags\": string[] (relationship types)\n        }\n        \n        Fact: \"${fact}\"\n        `;\n\n        try {\n            const result = await generateText({\n                runtime: this.runtime,\n                context: prompt,\n                modelClass: ModelClass.SMALL,\n            });\n\n            return JSON.parse(result);\n        } catch (error) {\n            elizaLogger.error(\"[FactValidation] Failed to extract relationships:\", error);\n            return [];\n        }\n    }\n\n    private calculateFactConfidence(\n        fact: string,\n        message: AlfaFrensMessage,\n        contradictions: Contradiction[]\n    ): number {\n        let confidence = 0.5; // Base confidence\n\n        // Adjust based on message source\n        if (message.senderId === this.runtime.agentId) {\n            confidence += 0.2; // Higher confidence for bot's own facts\n        }\n\n        // Adjust based on contradictions\n        if (contradictions.length > 0) {\n            const avgContradictionConfidence = contradictions.reduce(\n                (acc, c) => acc + c.confidence,\n                0\n            ) / contradictions.length;\n            confidence -= avgContradictionConfidence * 0.3;\n        }\n\n        // Ensure confidence is between 0 and 1\n        return Math.max(0, Math.min(1, confidence));\n    }\n\n    private calculateSemanticSimilarity(text1: string, text2: string): number {\n        const words1 = new Set(text1.toLowerCase().split(/\\s+/));\n        const words2 = new Set(text2.toLowerCase().split(/\\s+/));\n\n        const intersection = new Set([...words1].filter(x => words2.has(x)));\n        const union = new Set([...words1, ...words2]);\n\n        return intersection.size / union.size;\n    }\n\n    async storeFact(fact: string, validation: FactValidation): Promise<void> {\n        if (validation.confidence < this.confidenceThreshold) {\n            elizaLogger.debug(\"[FactValidation] Skipping low confidence fact:\", fact);\n            return;\n        }\n\n        try {\n            const memory: Memory = {\n                id: stringToUuid(`fact-${Date.now()}`),\n                content: {\n                    text: fact,\n                    metadata: {\n                        confidence: validation.confidence,\n                        source: validation.source,\n                        timestamp: validation.timestamp,\n                        contradictions: validation.contradictions,\n                        relationships: validation.relationships\n                    }\n                },\n                roomId: this.runtime.agentId,\n                userId: this.runtime.agentId,\n                agentId: this.runtime.agentId\n            };\n\n            await this.runtime.messageManager.createMemory(memory);\n        } catch (error) {\n            elizaLogger.error(\"[FactValidation] Failed to store fact:\", error);\n        }\n    }\n} ","import { IAgentRuntime, elizaLogger, generateText, ModelClass, ServiceType } from \"@elizaos/core\";\nimport type { AlfaFrensMessage } from \"../types\";\nimport type { AlfaFrensGenerationConfig } from \"../types\";\nimport { v4 as uuidv4 } from 'uuid';\nimport { FactValidationManager } from \"./fact-validation\";\n\n/**\n * process a template string with runtime data\n * @param template template string with placeholders\n * @param runtime ElizaOS runtime\n * @param additionalData additional data for replacement\n * @returns processed template\n */\nexport function processTemplate(\n    template: string,\n    runtime: IAgentRuntime,\n    additionalData: Record<string, any> = {}\n): string {\n    const character = runtime.character;\n    let result = template\n        .replace(/{{character\\.name}}/g, character.name)\n        .replace(/{{character\\.adjectives}}/g, character.adjectives.join(\", \"))\n        .replace(/{{character\\.topics}}/g, character.topics?.join(\", \") || \"\");\n\n    // process additional data if provided\n    Object.entries(additionalData).forEach(([key, value]) => {\n        if (typeof value === 'object') {\n            Object.entries(value).forEach(([subKey, subValue]) => {\n                result = result.replace(\n                    new RegExp(`{{${key}\\\\.${subKey}}}`, 'g'),\n                    String(subValue)\n                );\n            });\n        } else {\n            result = result.replace(\n                new RegExp(`{{${key}}}`, 'g'),\n                String(value)\n            );\n        }\n    });\n\n    return result;\n}\n\n/**\n * parse a model class string to ModelClass enum\n * @param modelClass string representation of model class\n * @returns ModelClass enum value or undefined\n */\nexport function parseModelClass(modelClass?: string): ModelClass | undefined {\n    if (!modelClass) return undefined;\n\n    switch (modelClass.toUpperCase()) {\n        case \"SMALL\": return ModelClass.SMALL;\n        case \"MEDIUM\": return ModelClass.MEDIUM;\n        case \"LARGE\": return ModelClass.LARGE;\n        default: return undefined;\n    }\n}\n\n/**\n * gets a numeric setting from the character file with a default value\n * @param runtime ElizaOS runtime\n * @param key setting key\n * @param defaultValue default value if not found\n * @returns numeric setting value\n */\nexport function getNumericSetting(\n    runtime: IAgentRuntime,\n    key: string,\n    defaultValue: number\n): number {\n    const value = runtime.getSetting(key);\n    if (!value) return defaultValue;\n    const parsed = parseInt(value, 10);\n    return isNaN(parsed) ? defaultValue : parsed;\n}\n\n/**\n * default template for generating post content\n */\nexport const DEFAULT_POST_TEMPLATE = `You are {{character.name}}, an AI assistant with the following traits:\n{{character.adjectives}}\n\nYour topics of expertise include:\n{{character.topics}}\n\nTASK: Write a new post for a community channel.\n\nRULES:\n1. Write ONLY the post content\n2. Do not include any meta-commentary\n3. Start directly with your message\n4. Keep it engaging and relevant\n5. Maximum length: 2-3 sentences\n6. Be concise and meaningful\n\nPOST:`;\n\n/**\n * default template for generating responses\n */\nexport const DEFAULT_RESPONSE_TEMPLATE = `You are {{character.name}}, an AI assistant with the following traits:\n{{character.adjectives}}\n\nYour topics of expertise include:\n{{character.topics}}\n\nCONVERSATION HISTORY:\n{{message.history}}\n\nUSER ({{message.sender}}): {{message.content}}\n\nTASK: Respond to the user's message.\n\nRULES:\n1. Keep responses concise (1-2 sentences)\n2. Be direct and helpful\n3. Stay focused on the question\n4. No meta-commentary\n\nYOUR RESPONSE:`;\n\n/**\n * default template for evaluating messages\n */\nexport const DEFAULT_EVALUATION_TEMPLATE = `TASK: Decide whether the AI assistant should respond to this message.\n\nMessage: \"{{message.content}}\"\nSender: {{message.sender}}\n\nINSTRUCTIONS:\nYou are helping me decide if the AI assistant should respond to the message above.\nConsider the following:\n1. Is this a substantial message that requires a response?\n2. Is the message directed at the assistant?\n3. Is the message a question, request for help, or engaging in conversation?\n4. Is the message appropriate to respond to?\n\nResponse format:\nReturn a JSON array with:\n1. A boolean (true/false) indicating whether to respond\n2. A brief explanation for your decision\n\nExample response:\n\\`\\`\\`json\n[true, \"This is a direct question that the assistant should answer\"]\n\\`\\`\\`\n\nOr:\n\\`\\`\\`json\n[false, \"This message is too short and doesn't require a response\"]\n\\`\\`\\`\n`;\n\n/**\n * format conversation history for context\n * @param messages array of messages to format\n * @returns formatted conversation history\n */\nfunction formatConversationHistory(messages: AlfaFrensMessage[]): string {\n    if (messages.length === 0) {\n        return \"No previous messages.\";\n    }\n\n    return messages.map(msg => {\n        const role = msg.senderId === msg.senderUsername ?\n            \"ASSISTANT\" :\n            `USER (${msg.senderUsername})`;\n        return `${role}: ${msg.content}`;\n    }).join(\"\\n\\n\");\n}\n\n/**\n * common function for generating text with LLM with detailed logging\n */\nasync function generateLLMResponse({\n    runtime,\n    context,\n    modelClass,\n    logPrefix = \"[AlfaFrens]\",\n    traceId = \"\"\n}: {\n    runtime: IAgentRuntime;\n    context: string;\n    modelClass: ModelClass;\n    logPrefix?: string;\n    traceId?: string;\n}): Promise<string> {\n    const id = traceId ? ` (${traceId})` : \"\";\n    elizaLogger.debug(`${logPrefix} Generating text with parameters${id}:`, {\n        modelClass,\n        contextLength: context.length,\n        contextPreview: context.substring(0, 100) + (context.length > 100 ? '...' : ''),\n        runtimeHasCharacter: !!runtime.character,\n        runtimeHasModelProvider: !!runtime.modelProvider\n    });\n\n    try {\n        // add a timeout to the LLM call to prevent hanging\n        const timeoutPromise = new Promise<string>((_, reject) => {\n            setTimeout(() => reject(new Error(\"LLM request timed out\")), 30000); // 30 second timeout\n        });\n\n        const llmPromise = generateText({\n            runtime,\n            context,\n            modelClass,\n            stop: [\"\\n\\n\"],\n            customSystemPrompt: \"You are a helpful assistant that responds as accurately as possible.\",\n        });\n\n        // race the LLM call against a timeout\n        const result = await Promise.race([llmPromise, timeoutPromise]);\n\n        elizaLogger.debug(`${logPrefix} Generated text${id}:`, {\n            resultLength: result.length,\n            resultPreview: result.substring(0, 100) + (result.length > 100 ? '...' : '')\n        });\n\n        return result;\n    } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n\n        // check for common API errors\n        if (errorMessage.includes(\"authentication\") || errorMessage.includes(\"api key\")) {\n            elizaLogger.error(`${logPrefix} Authentication error with API${id}:`, errorMessage);\n            console.error(`=== LLM API AUTHENTICATION ERROR [${traceId || 'unknown'}] ===`);\n            console.error(errorMessage);\n        } else if (errorMessage.includes(\"timeout\")) {\n            elizaLogger.error(`${logPrefix} Timeout error calling LLM API${id}:`, errorMessage);\n            console.error(`=== LLM API TIMEOUT [${traceId || 'unknown'}] ===`);\n        } else {\n            elizaLogger.error(`${logPrefix} Error generating text${id}:`, error);\n            console.error(`=== LLM API ERROR [${traceId || 'unknown'}] ===`, errorMessage);\n        }\n\n        // rethrow so caller can handle\n        throw error;\n    }\n}\n\n/**\n * generates post content using the AI\n */\nexport async function generatePostContent(\n    runtime: IAgentRuntime,\n    config: AlfaFrensGenerationConfig['post']\n): Promise<string> {\n    elizaLogger.debug(\"[AlfaFrens] Starting post content generation\");\n\n    elizaLogger.debug(\"[AlfaFrens] Using template:\", config.template?.substring(0, 50) + \"...\");\n    elizaLogger.debug(\"[AlfaFrens] Using model class:\", config.modelClass);\n\n    const context = processTemplate(config.template, runtime);\n\n    try {\n        const content = await generateLLMResponse({\n            runtime,\n            context,\n            modelClass: config.modelClass,\n            traceId: \"post\"\n        });\n\n        elizaLogger.info(\"[AlfaFrens] Generated post content:\", content);\n        return content;\n    } catch (error) {\n        elizaLogger.error(\"[AlfaFrens] Failed to generate post content:\", error);\n        return \"I'm sorry, I couldn't generate a post at this time.\";\n    }\n}\n\n/**\n * Generates a response to a message\n */\nexport async function generateResponse(\n    runtime: IAgentRuntime,\n    client: any,\n    message: string,\n    messageHistory: any[],\n    template: string,\n    modelClass?: ModelClass\n): Promise<string> {\n    // Explicitly check for web search service and try to use it\n    let webSearchResults = \"\";\n    try {\n        const webSearchService = runtime.getService(ServiceType.WEB_SEARCH);\n        if (webSearchService) {\n            elizaLogger.info(\"[AlfaFrens] Web search service found, attempting to search for: \" + message);\n            // Cast the service to any to access its search method\n            const searchResults = await (webSearchService as any).search(message, {\n                limit: 3,\n                includeAnswer: true\n            });\n\n            if (searchResults && searchResults.results && searchResults.results.length > 0) {\n                elizaLogger.info(\"[AlfaFrens] Web search results found!\");\n                webSearchResults = `${searchResults.answer || \"\"}\\n\\nRelevant web search results:\\n`;\n                webSearchResults += searchResults.results.map((result: any, i: number) =>\n                    `${i + 1}. ${result.title} - ${result.url}`\n                ).join('\\n');\n            }\n        } else {\n            elizaLogger.warn(\"[AlfaFrens] Web search service not found\");\n        }\n    } catch (error) {\n        elizaLogger.error(\"[AlfaFrens] Error using web search service:\", error);\n    }\n\n    // Get relevant knowledge for this message\n    let knowledgeContext = \"\";\n    try {\n        // Use the client's knowledge search capability\n        const knowledgeResults = await client.searchKnowledge(message, 3);\n        if (knowledgeResults && knowledgeResults.length > 0) {\n            knowledgeContext = \"\\n\\nRelevant knowledge:\\n\" +\n                knowledgeResults.map(r => r.content?.text || \"\").filter(Boolean).join(\"\\n\\n\");\n        }\n    } catch (error) {\n        elizaLogger.warn(\"[AlfaFrens] Error fetching knowledge context:\", error);\n    }\n\n    // Format the history for the prompt\n    const formattedHistory = formatConversationHistory(messageHistory);\n\n    // Add knowledge context and web search results to the message\n    const contextEnhancedMessage = message;\n\n    // Process the template with the message, history, and web search results\n    let prompt = processTemplate(template, runtime, {\n        message: {\n            content: contextEnhancedMessage,\n            history: formattedHistory\n        },\n        websearch: webSearchResults,\n        knowledge: knowledgeContext\n    });\n\n    // Generate the response\n    const rawResponse = await generateLLMResponse({\n        runtime,\n        context: prompt,\n        modelClass: modelClass || ModelClass.MEDIUM,\n        traceId: \"response\"\n    });\n\n    // Perform fact validation\n    const factValidationManager = new FactValidationManager(runtime);\n\n    try {\n        // Extract facts from the generated response\n        const extractedFacts = await factValidationManager.extractFacts(rawResponse);\n        elizaLogger.debug(\"[AlfaFrens] Extracted facts from response:\", extractedFacts);\n\n        if (extractedFacts.length === 0) {\n            // No facts to validate, return the original response\n            return rawResponse;\n        }\n\n        // Create a dummy message for validation context\n        const dummyMessage = {\n            id: `validation-${Date.now()}`,\n            timestamp: new Date().toISOString(),\n            content: rawResponse,\n            senderId: runtime.agentId,\n            senderUsername: runtime.character?.name || \"AI Assistant\"\n        };\n\n        // Validate each extracted fact\n        let requiresCorrection = false;\n        const factValidationResults = [];\n\n        for (const fact of extractedFacts) {\n            const validation = await factValidationManager.validateFact(fact, dummyMessage);\n            factValidationResults.push({\n                fact,\n                confidence: validation.confidence,\n                contradictions: validation.contradictions\n            });\n\n            // If the fact has contradictions or low confidence, we might need to correct the response\n            if (validation.contradictions.length > 0 || validation.confidence < 0.7) {\n                requiresCorrection = true;\n            }\n        }\n\n        elizaLogger.debug(\"[AlfaFrens] Fact validation results:\", factValidationResults);\n\n        // If corrections are needed, regenerate with corrected context\n        if (requiresCorrection) {\n            elizaLogger.info(\"[AlfaFrens] Facts require correction, enhancing prompt with factual context\");\n\n            // Create a correction context\n            const correctionContext = factValidationResults\n                .filter(r => r.contradictions.length > 0 || r.confidence < 0.7)\n                .map(r => {\n                    if (r.contradictions.length > 0) {\n                        return `CORRECTION: \"${r.fact}\" contradicts known facts: ${r.contradictions.join(\", \")}`;\n                    } else {\n                        return `CORRECTION: \"${r.fact}\" has low confidence (${r.confidence.toFixed(2)})`;\n                    }\n                })\n                .join(\"\\n\");\n\n            // Create a revised prompt with correction context\n            const revisedPrompt = `${prompt}\\n\\nYour initial response contains factual issues that need correction:\\n${correctionContext}\\n\\nRevised response:`;\n\n            // Generate a corrected response\n            const correctedResponse = await generateLLMResponse({\n                runtime,\n                context: revisedPrompt,\n                modelClass: modelClass || ModelClass.MEDIUM,\n                traceId: \"corrected-response\"\n            });\n\n            elizaLogger.info(\"[AlfaFrens] Generated fact-corrected response\");\n            return correctedResponse;\n        }\n\n        // Store validated facts with high confidence\n        for (const result of factValidationResults) {\n            if (result.confidence >= 0.7 && result.contradictions.length === 0) {\n                await factValidationManager.storeFact(result.fact, {\n                    confidence: result.confidence,\n                    source: runtime.agentId,\n                    timestamp: Date.now(),\n                    contradictions: []\n                });\n            }\n        }\n    } catch (error) {\n        // If fact validation fails, log and return the original response\n        elizaLogger.error(\"[AlfaFrens] Error during fact validation:\", error);\n        elizaLogger.warn(\"[AlfaFrens] Returning original response due to fact validation error\");\n    }\n\n    return rawResponse;\n}\n\n/**\n * evaluate a message to determine if the AI should respond\n * @param runtime agent runtime\n * @param message the message to evaluate\n * @param config configuration for evaluation\n * @returns boolean indicating whether to respond\n */\nexport async function evaluateMessage(\n    runtime: IAgentRuntime,\n    message: AlfaFrensMessage,\n    config: { template: string, modelClass?: ModelClass }\n): Promise<boolean> {\n    // generate a unique trace ID for this evaluation call\n    const traceId = `eval-${message.id.substring(0, 8)}-${Date.now().toString().substring(9, 13)}`;\n\n    // remove console.log statements\n    elizaLogger.debug(`[EVALUATION START ${traceId}] Message from ${message.senderUsername}: ${message.content?.substring(0, 100)}`);\n\n    // force debug mode: skip LLM evaluation and always return true\n    // remove console.log statements\n    elizaLogger.debug(`[FORCE DEBUG MODE] Skipping LLM evaluation and returning TRUE`);\n\n    return true;\n}","import { IAgentRuntime, elizaLogger, Action, Memory } from \"@elizaos/core\";\nimport { AlfaFrensManager } from \"../alfafrens-client\";\nimport { generatePostContent, generateResponse } from \"./utils\";\nimport { loadAlfaFrensConfig } from \"../config\";\nimport type { AlfaFrensMessage, AlfaFrensMemoryContent } from \"../types\";\n\n/**\n * gets message history for a conversation\n */\nasync function getMessageHistory(\n    client: AlfaFrensManager,\n    message: Memory,\n    maxHistory: number = 5\n): Promise<AlfaFrensMessage[]> {\n    try {\n        const content = message.content as AlfaFrensMemoryContent;\n        const replyTo = content.inReplyTo;\n\n        if (!replyTo) {\n            return [];\n        }\n\n        const messages = await client.getMessages({\n            roomId: client.config.channelId,\n            until: Date.now(),\n            includeReplies: true\n        });\n\n        // filter messages to get the conversation thread\n        const thread: AlfaFrensMessage[] = [];\n        let currentMessage = messages.find(m => m.id === replyTo);\n\n        while (currentMessage && thread.length < maxHistory) {\n            thread.unshift(currentMessage);\n            if (currentMessage.replyTo) {\n                currentMessage = messages.find(m => m.id === currentMessage.replyTo);\n            } else {\n                break;\n            }\n        }\n\n        return thread;\n    } catch (error) {\n        elizaLogger.error(\"[AlfaFrensAction] failed to get message history:\", error);\n        return [];\n    }\n}\n\n/**\n * creates AlfaFrens actions that can be registered with the ElizaOS runtime\n */\nexport function createAlfaFrensActions(\n    client: AlfaFrensManager,\n    runtime: IAgentRuntime\n): Action[] {\n    const config = loadAlfaFrensConfig(runtime);\n\n    return [\n        {\n            name: \"ALFAFRENS_CREATE_POST\",\n            description: \"creates a new post in the AlfaFrens channel\",\n            similes: [\"post\", \"share\", \"announce\", \"publish\"],\n            examples: [\n                [\n                    {\n                        user: \"{{user1}}\",\n                        content: { text: \"create a new post about community updates\" }\n                    },\n                    {\n                        user: \"{{user2}}\",\n                        content: { text: \"Exciting new features coming to our platform! Stay tuned for updates.\", action: \"ALFAFRENS_CREATE_POST\" }\n                    }\n                ]\n            ],\n            validate: async (_runtime: IAgentRuntime, _message: Memory) => {\n                return true;\n            },\n            handler: async (runtime: IAgentRuntime, message: Memory) => {\n                try {\n                    const content = (message.content as AlfaFrensMemoryContent).text ||\n                        await generatePostContent(runtime, config.post);\n\n                    elizaLogger.debug(\"[AlfaFrensAction] creating post with content:\", content);\n                    await client.createPost({\n                        content,\n                        roomId: client.config.channelId\n                    });\n\n                    elizaLogger.info(\"[AlfaFrensAction] post created successfully\");\n                    return true;\n                } catch (error) {\n                    elizaLogger.error(\"[AlfaFrensAction] failed to create post:\", error);\n                    return false;\n                }\n            }\n        },\n        {\n            name: \"ALFAFRENS_RESPOND\",\n            description: \"responds to a message in the AlfaFrens channel\",\n            similes: [\"reply\", \"answer\", \"respond\"],\n            examples: [\n                [\n                    {\n                        user: \"{{user1}}\",\n                        content: { text: \"What's the latest update?\" }\n                    },\n                    {\n                        user: \"{{user2}}\",\n                        content: { text: \"We've just launched new features! Check them out.\", action: \"ALFAFRENS_RESPOND\" }\n                    }\n                ]\n            ],\n            validate: async (_runtime: IAgentRuntime, _message: Memory) => {\n                return true;\n            },\n            handler: async (runtime: IAgentRuntime, message: Memory) => {\n                try {\n                    const content = message.content as AlfaFrensMemoryContent;\n                    const history = await getMessageHistory(client, message);\n\n                    const responseContent = content.text || await generateResponse(\n                        runtime,\n                        client,\n                        content.text || \"\",\n                        history,\n                        config.response.template,\n                        config.response.modelClass\n                    );\n\n                    elizaLogger.debug(\"[AlfaFrensAction] sending response:\", {\n                        contentLength: responseContent.length,\n                        replyTo: content.inReplyTo\n                    });\n\n                    await client.sendMessage({\n                        content: responseContent,\n                        roomId: client.config.channelId,\n                        inReplyTo: content.inReplyTo\n                    });\n\n                    elizaLogger.info(\"[AlfaFrensAction] response sent successfully\");\n                    return true;\n                } catch (error) {\n                    elizaLogger.error(\"[AlfaFrensAction] failed to send response:\", error);\n                    return false;\n                }\n            }\n        }\n    ];\n}\n\n/**\n * registers AlfaFrens actions with the ElizaOS runtime\n */\nexport function registerAlfaFrensActions(\n    client: AlfaFrensManager,\n    runtime: IAgentRuntime\n): void {\n    const actions = createAlfaFrensActions(client, runtime);\n\n    elizaLogger.debug(`[AlfaFrensActions] registering ${actions.length} actions`);\n\n    actions.forEach(action => {\n        runtime.registerAction(action);\n    });\n\n    elizaLogger.info(\"[AlfaFrensActions] actions registered successfully\");\n} ","import { elizaLogger, IAgentRuntime, ClientInstance, stringToUuid, Client, Action, Memory, UUID } from \"@elizaos/core\";\nimport { AlfaFrensApi } from \"./api\";\nimport { loadAlfaFrensConfig } from \"./config\";\nimport { createAlfaFrensMemory } from \"./memory\";\nimport { generatePostContent, parseModelClass, DEFAULT_POST_TEMPLATE, evaluateMessage, DEFAULT_EVALUATION_TEMPLATE } from \"./extensions/utils\";\nimport { AlfaFrensAIInteraction, AlfaFrensClient } from \"./extensions/ai-interaction\";\nimport { AlfaFrensConfig, AlfaFrensGenerationConfig, AlfaFrensMessage, AlfaFrensSendMessageResponse, AlfaFrensMemoryContent } from \"./types\";\n\n// Configure ElizaOS logger\nelizaLogger.debug(\"Initializing AlfaFrens client\");\n\n// Type extension for the reply action\ntype AlfaFrensReplyContent = AlfaFrensMemoryContent & { messageId?: string };\n\n// Define action implementations first\n/**\n * replies to a message in the AlfaFrens channel\n */\nexport const replyAlfaFrensMessageAction: Action = {\n    name: \"ALFAFRENS_REPLY\",\n    description: \"replies to a specific message in the AlfaFrens channel\",\n    similes: [\"reply\", \"respond\", \"answer\", \"comment\"],\n    examples: [[\n        {\n            user: \"user\",\n            content: {\n                text: \"reply to message 123 with 'Thanks for your input!'\",\n                action: \"ALFAFRENS_REPLY\",\n                messageId: \"123\"\n            }\n        }\n    ]],\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensReplyContent;\n        if (!content?.text) {\n            elizaLogger.error(\"[AlfaFrens] reply content is missing\");\n            return false;\n        }\n        if (!content?.messageId) {\n            elizaLogger.error(\"[AlfaFrens] messageId to reply to is missing\");\n            return false;\n        }\n        return true;\n    },\n    handler: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensReplyContent;\n        const client = runtime.clients.find(c =>\n            c.constructor.name === \"AlfaFrensManager\") as unknown as AlfaFrensManager;\n        if (!client) {\n            elizaLogger.error(\"[AlfaFrens] client not found\");\n            return false;\n        }\n\n        try {\n            await client.sendMessage({\n                content: content.text,\n                roomId: client.config.channelId,\n                inReplyTo: content.messageId\n            });\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrens] failed to reply to message:\", error);\n            return false;\n        }\n    }\n};\n\n/**\n * sends a message to the AlfaFrens channel\n */\nexport const sendAlfaFrensMessageAction: Action = {\n    name: \"ALFAFRENS_SEND_MESSAGE\",\n    description: \"sends a message to the AlfaFrens channel\",\n    similes: [\"send\", \"message\", \"chat\", \"respond\"],\n    examples: [[\n        {\n            user: \"user\",\n            content: {\n                text: \"send a message to AlfaFrens\",\n                action: \"ALFAFRENS_SEND_MESSAGE\"\n            }\n        }\n    ]],\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensMemoryContent;\n        if (!content?.text) {\n            elizaLogger.error(\"[AlfaFrens] message content is missing\");\n            return false;\n        }\n        return true;\n    },\n    handler: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensMemoryContent;\n        const client = runtime.clients.find(c =>\n            c.constructor.name === \"AlfaFrensManager\") as unknown as AlfaFrensManager;\n        if (!client) {\n            elizaLogger.error(\"[AlfaFrens] client not found\");\n            return false;\n        }\n\n        try {\n            await client.sendMessage({\n                content: content.text,\n                roomId: client.config.channelId\n            });\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrens] failed to send message:\", error);\n            return false;\n        }\n    }\n};\n\n/**\n * creates a new post in the AlfaFrens channel\n */\nexport const createAlfaFrensPostAction: Action = {\n    name: \"ALFAFRENS_CREATE_POST\",\n    description: \"creates a new post in the AlfaFrens channel\",\n    similes: [\"post\", \"share\", \"announce\", \"publish\"],\n    examples: [[\n        {\n            user: \"user\",\n            content: {\n                text: \"create a post in AlfaFrens\",\n                action: \"ALFAFRENS_CREATE_POST\"\n            }\n        }\n    ]],\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensMemoryContent;\n        if (!content?.text) {\n            elizaLogger.error(\"[AlfaFrens] post content is missing\");\n            return false;\n        }\n        return true;\n    },\n    handler: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensMemoryContent;\n        const client = runtime.clients.find(c =>\n            c.constructor.name === \"AlfaFrensManager\") as unknown as AlfaFrensManager;\n        if (!client) {\n            elizaLogger.error(\"[AlfaFrens] client not found\");\n            return false;\n        }\n\n        try {\n            await client.createPost({\n                content: content.text,\n                roomId: client.config.channelId\n            });\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrens] failed to create post:\", error);\n            return false;\n        }\n    }\n};\n\n/**\n * Manager for interacting with AlfaFrens API\n */\nexport class AlfaFrensManager implements ClientInstance, AlfaFrensClient {\n    /**\n     * API client\n     */\n    api: AlfaFrensApi;\n\n    /**\n     * Configuration\n     */\n    config: AlfaFrensConfig;\n\n    /**\n     * Pre-loaded generation configuration\n     */\n    private generationConfig: AlfaFrensGenerationConfig;\n\n    /**\n     * AI interaction manager\n     */\n    aiInteraction: AlfaFrensAIInteraction | null = null;\n\n    /**\n     * Agent runtime\n     */\n    runtime: IAgentRuntime;\n\n    /**\n     * Current operation status\n     */\n    isRunning = false;\n\n    /**\n     * Last processed time for messages\n     */\n    private lastProcessedTime: number = 0;\n\n    /**\n     * Client name for ElizaOS\n     */\n    name = \"alfafrens\";\n\n    /**\n     * Client description for ElizaOS\n     */\n    description = \"AlfaFrens client manager\";\n\n    /**\n     * Create a new AlfaFrens manager\n     * @param runtime Agent runtime\n     */\n    constructor(runtime: IAgentRuntime) {\n        elizaLogger.debug(\"[AlfaFrensManager] Initializing with runtime\");\n\n        this.runtime = runtime;\n\n        this.config = {\n            apiKey: runtime.getSetting(\"ALFAFRENS_API_KEY\") || \"\",\n            userId: runtime.getSetting(\"ALFAFRENS_USER_ID\") || \"\",\n            channelId: runtime.getSetting(\"ALFAFRENS_CHANNEL_ID\"),\n            username: runtime.getSetting(\"ALFAFRENS_USERNAME\") || \"AI Assistant\",\n            pollInterval: parseInt(runtime.getSetting(\"ALFAFRENS_POLL_INTERVAL\") || \"15\"),\n            enablePost: runtime.getSetting(\"ALFAFRENS_ENABLE_POST\") === \"true\",\n            postIntervalMin: parseInt(runtime.getSetting(\"ALFAFRENS_POST_INTERVAL_MIN\") || \"3600\"),\n            postIntervalMax: parseInt(runtime.getSetting(\"ALFAFRENS_POST_INTERVAL_MAX\") || \"7200\")\n        };\n\n        // Ensure API key is provided\n        if (!this.config.apiKey) {\n            throw new Error(\"AlfaFrens API key is required\");\n        }\n\n        // Create the API client\n        this.api = new AlfaFrensApi(this.config.apiKey, this.config.channelId);\n\n        // Load the generation configuration\n        this.generationConfig = loadAlfaFrensConfig(runtime);\n\n        // Initialize AI interaction\n        this.aiInteraction = new AlfaFrensAIInteraction(\n            this,\n            runtime,\n            {\n                evaluationTemplate: this.generationConfig.evaluation.template,\n                responseTemplate: this.generationConfig.response.template,\n                modelClass: this.generationConfig.response.modelClass,\n                intervalSeconds: this.config.pollInterval,\n                postTemplate: this.generationConfig.post.template,\n                generationConfig: this.generationConfig\n            }\n        );\n\n        elizaLogger.debug(\"[AlfaFrensManager] Initialized successfully\");\n    }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        elizaLogger.debug(\"AlfaFrensManager.initialize called\");\n        if (this.isRunning) {\n            elizaLogger.debug(\"AlfaFrensManager already running, returning early\");\n            elizaLogger.warn(\"[AlfaFrensManager] Already running\");\n            return;\n        }\n\n        elizaLogger.info(\"[AlfaFrensManager] Starting AlfaFrens client\");\n        this.isRunning = true;\n\n        try {\n            // Get last processed time from cache\n            elizaLogger.debug(\"AlfaFrensManager getting last processed time from cache\");\n            const cached = await this.runtime.cacheManager.get<number>(\"alfafrens_last_processed_time\");\n            this.lastProcessedTime = cached || Date.now() - (5 * 60 * 1000); // Default to 5 minutes ago\n            elizaLogger.debug(\"AlfaFrensManager lastProcessedTime set to:\", this.lastProcessedTime);\n\n            // Register AlfaFrens actions with ElizaOS\n            const { registerAlfaFrensActions } = await import(\"./extensions/actions\");\n            registerAlfaFrensActions(this, runtime);\n            elizaLogger.debug(\"AlfaFrensManager registered actions with ElizaOS\");\n\n            // Start AI interaction with poll interval\n            elizaLogger.debug(\"AlfaFrensManager starting aiInteraction with poll interval:\", this.config.pollInterval);\n            await this.aiInteraction?.start(this.config.pollInterval);\n            elizaLogger.debug(\"AlfaFrensManager aiInteraction.start completed\");\n\n            // Make initial post when bot starts\n            elizaLogger.info(\"[AlfaFrensManager] Making initial post...\");\n            const initialMessage = \"Hey AlfaFrens! I'm back online and ready to help with your questions. Feel free to ask anything!\";\n            await this.sendMessage({\n                content: initialMessage,\n                roomId: this.config.channelId\n            });\n            elizaLogger.info(\"[AlfaFrensManager] Initial post sent successfully\");\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrensManager] ERROR in AlfaFrensManager.initialize:\", error);\n            elizaLogger.error(\"[AlfaFrensManager] Failed to start:\", error);\n            this.isRunning = false;\n            throw error;\n        }\n    }\n\n    async stop(runtime: IAgentRuntime): Promise<unknown> {\n        if (!this.isRunning) {\n            elizaLogger.warn(\"[AlfaFrensManager] Not running\");\n            return;\n        }\n\n        elizaLogger.info(\"[AlfaFrensManager] Stopping AlfaFrens client\");\n        this.isRunning = false;\n\n        try {\n            // Save last processed time to cache\n            await this.runtime.cacheManager.set(\"alfafrens_last_processed_time\", this.lastProcessedTime);\n\n            // Stop AI interaction\n            await this.aiInteraction?.stop();\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrensManager] Failed to stop:\", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Get messages from AlfaFrens API\n     */\n    async getMessages(params: {\n        roomId: string;\n        since?: number;\n        until?: number;\n        includeReactions?: boolean;\n        includeReplies?: boolean;\n    }): Promise<AlfaFrensMessage[]> {\n        try {\n            // Call the API to get messages\n            const messages = await this.api.getMessages({\n                since: params.since,\n                until: params.until,\n                includeReactions: params.includeReactions,\n                includeReplies: params.includeReplies\n            });\n            return messages;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrensManager] Error getting messages:\", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Creates a message from API response and prepares memory\n     */\n    private prepareMessageAndMemory(response: AlfaFrensSendMessageResponse, content: string, roomId: string): { memory: any; message: AlfaFrensMessage } {\n        const message = createMessageFromResponse(response, content);\n\n        // Set sender info\n        message.senderId = this.config.userId;\n        message.senderUsername = this.config.username || \"AI Assistant\";\n\n        const memory = createAlfaFrensMemory({\n            roomId: stringToUuid(roomId),\n            senderId: this.runtime.agentId,\n            runtime: this.runtime,\n            message,\n            isBotMessage: true // This is a message from the bot\n        });\n\n        return { memory, message };\n    }\n\n    async sendMessage(params: {\n        content: string;\n        roomId: string;\n        inReplyTo?: string;\n    }): Promise<{ memory: any; message: AlfaFrensMessage }[]> {\n        try {\n            elizaLogger.debug(\"[AlfaFrensManager] Sending message:\", {\n                contentLength: params.content.length,\n                roomId: params.roomId,\n                inReplyTo: params.inReplyTo\n            });\n\n            // Use appropriate method based on whether it's a reply\n            let response;\n            if (params.inReplyTo) {\n                response = await this.api.replyMessage(params.content, params.inReplyTo);\n            } else {\n                response = await this.api.sendMessage(params.content);\n            }\n\n            const result = this.prepareMessageAndMemory(response, params.content, params.roomId);\n\n            elizaLogger.debug(\"[AlfaFrensManager] Message sent successfully\");\n            return [result];\n        } catch (error) {\n            elizaLogger.error('[AlfaFrensManager] Failed to send message:', error);\n            throw error;\n        }\n    }\n\n    async createPost(params: {\n        content: string;\n        roomId: string;\n    }): Promise<{ memory: any; message: AlfaFrensMessage }[]> {\n        try {\n            elizaLogger.debug(\"[AlfaFrensManager] Creating post:\", {\n                contentLength: params.content.length,\n                roomId: params.roomId\n            });\n\n            const response = await this.api.createPost(params.content);\n\n            const result = this.prepareMessageAndMemory(response, params.content, params.roomId);\n\n            elizaLogger.debug(\"[AlfaFrensManager] Post created successfully\");\n            return [result];\n        } catch (error) {\n            elizaLogger.error('[AlfaFrensManager] Failed to create post:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Search knowledge base using ElizaOS's built-in knowledge system\n     * @param query Search query\n     * @param limit Maximum number of results\n     */\n    async searchKnowledge(query: string, limit: number = 5): Promise<any[]> {\n        try {\n            // Use ElizaOS's built-in RAG knowledge system\n            const results = await this.runtime.ragKnowledgeManager.getKnowledge({\n                query: query,\n                limit: limit,\n                agentId: this.runtime.agentId\n            });\n            return results;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrensManager] Error searching knowledge:\", error);\n            return [];\n        }\n    }\n\n    /**\n     * Get knowledge context for a given query\n     * @param query Search query\n     */\n    async getKnowledgeContext(query: string): Promise<string> {\n        try {\n            const results = await this.searchKnowledge(query);\n            if (results && results.length > 0) {\n                return results.map(r => r.content).join(\"\\n\\n\");\n            }\n            return \"\";\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrensManager] Error getting knowledge context:\", error);\n            return \"\";\n        }\n    }\n}\n\nexport const AlfaFrensClientInterface: Client = {\n    name: \"alfafrens\",\n\n    async start(runtime: IAgentRuntime): Promise<ClientInstance> {\n        elizaLogger.debug(\"AlfaFrensClientInterface.start called\");\n        elizaLogger.info(\"[AlfaFrensClient] Starting client\");\n        const manager = new AlfaFrensManager(runtime);\n        elizaLogger.debug(\"AlfaFrensClientInterface created new AlfaFrensManager instance\");\n        await manager.initialize(runtime);\n        elizaLogger.debug(\"AlfaFrensClientInterface called initialize on manager\");\n        return manager;\n    }\n};\n\n// Export the actions array\nexport const actions = [\n    sendAlfaFrensMessageAction,\n    createAlfaFrensPostAction,\n    replyAlfaFrensMessageAction\n];\n\n/**\n * Converts API response to AlfaFrensMessage\n */\nfunction createMessageFromResponse(response: AlfaFrensSendMessageResponse, content: string): AlfaFrensMessage {\n    return {\n        id: response.messageId,\n        timestamp: response.timestamp,\n        content: content,\n        senderId: \"\", // Will be set from config\n        senderUsername: \"\" // Will be set from config\n    };\n} ","import { AlfaFrensMessage, AlfaFrensSendMessageResponse } from \"./types\";\nimport { elizaLogger } from \"@elizaos/core\";\n\n/**\n * AlfaFrens API client - handles HTTP communication with the AlfaFrens API\n */\nexport class AlfaFrensApi {\n    private baseUrl: string;\n\n    constructor(\n        private apiKey: string,\n        private channelId: string,\n        baseUrl?: string\n    ) {\n        elizaLogger.debug(\"[AlfaFrensApi] constructor called with channelId:\", channelId);\n        this.baseUrl = baseUrl || process.env.ALFAFRENS_API_URL || \"https://friendx-git-ai-api.preview.superfluid.finance\";\n        elizaLogger.debug(\"[AlfaFrensApi] using baseUrl:\", this.baseUrl);\n    }\n\n    private async fetch<T>(path: string, options: RequestInit = {}): Promise<T> {\n        elizaLogger.debug(\"[AlfaFrensApi] fetch called with path:\", path);\n        const response = await fetch(`${this.baseUrl}${path}`, {\n            ...options,\n            headers: {\n                \"x-api-key\": this.apiKey,\n                \"Content-Type\": \"application/json\",\n                ...options.headers\n            }\n        });\n\n        elizaLogger.debug(\"[AlfaFrensApi] fetch response status:\", response.status);\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error(\"[AlfaFrensApi] API Error:\", {\n                status: response.status,\n                statusText: response.statusText,\n                body: errorText\n            });\n            throw new Error(`API request failed: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n        elizaLogger.debug(\"[AlfaFrensApi] fetch response data type:\", Array.isArray(data) ? `Array[${data.length}]` : typeof data);\n        return data;\n    }\n\n    /**\n     * Gets messages from the channel\n     * @param options Options for fetching messages\n     * @returns Array of messages\n     */\n    async getMessages(options: {\n        since?: number;\n        until?: number;\n        includeReactions?: boolean;\n        includeReplies?: boolean;\n    } = {}): Promise<AlfaFrensMessage[]> {\n        elizaLogger.debug(\"[AlfaFrensApi] getMessages called with options:\", options);\n        try {\n            // Build URL with since parameter\n            let url = `/api/ai/getChannelMessages?since=${options.since || Date.now() - 3600000}`;\n\n            // Add until parameter if provided\n            if (options.until) {\n                url += `&until=${options.until}`;\n            }\n\n            // Add include parameter for reactions and replies\n            if (options.includeReactions || options.includeReplies) {\n                let includeValues = [];\n\n                if (options.includeReactions) {\n                    includeValues.push(\"reactions\");\n                }\n\n                if (options.includeReplies) {\n                    // Always include reactions when including replies for proper display\n                    includeValues = [\"reactions\", \"replies\"];\n                }\n\n                if (includeValues.length > 0) {\n                    url += \"&include=\" + includeValues.join(\",\");\n                }\n            }\n\n            elizaLogger.debug(\"[AlfaFrensApi] Fetching messages with URL:\", url);\n\n            // The API returns an array directly\n            const response = await this.fetch<AlfaFrensMessage[]>(url);\n\n            if (response.length > 0) {\n                elizaLogger.debug(`[AlfaFrensApi] Retrieved ${response.length} messages`);\n            }\n\n            return response;\n        } catch (error) {\n            console.error(\"[AlfaFrensApi] Error retrieving messages:\", error);\n            elizaLogger.error(\"[AlfaFrensApi] Failed to get messages:\", error);\n            throw error;\n        }\n    }\n\n    /**\n     * Sends a new message to the channel\n     * @param content Message content\n     * @returns Response object with message ID and timestamp\n     */\n    async sendMessage(content: string): Promise<AlfaFrensSendMessageResponse> {\n        return this.sendMessageWithOptions(content);\n    }\n\n    /**\n     * Replies to an existing message in the channel\n     * @param content Reply content\n     * @param replyToPostId ID of the message to reply to\n     * @returns Response object with message ID and timestamp\n     */\n    async replyMessage(content: string, replyToPostId: string): Promise<AlfaFrensSendMessageResponse> {\n        return this.sendMessageWithOptions(content, replyToPostId);\n    }\n\n    /**\n     * Creates a new post in the channel\n     * @param content Post content\n     * @returns Response object with message ID and timestamp\n     */\n    async createPost(content: string): Promise<AlfaFrensSendMessageResponse> {\n        return this.sendMessageWithOptions(content);\n    }\n\n    /**\n     * Internal method to send messages with options\n     */\n    private async sendMessageWithOptions(content: string, replyTo?: string): Promise<AlfaFrensSendMessageResponse> {\n        try {\n            const payload: any = {\n                content: content.trim()\n            };\n\n            if (replyTo) {\n                payload.replyToPostId = replyTo;\n            }\n\n            const response = await this.fetch<AlfaFrensSendMessageResponse>('/api/ai/postMessage', {\n                method: 'POST',\n                body: JSON.stringify(payload)\n            });\n\n            return response;\n        } catch (error) {\n            console.error('[AlfaFrensApi] Error sending message:', error);\n            throw error;\n        }\n    }\n} ","import { Memory, IAgentRuntime, stringToUuid, UUID } from \"@elizaos/core\";\nimport type { AlfaFrensMessage } from \"./types\";\n\n/**\n * create a memory for an AlfaFrens message\n * @param params memory parameters\n * @returns created memory\n */\nexport function createAlfaFrensMemory(params: {\n    roomId: UUID;\n    senderId: UUID;\n    runtime: IAgentRuntime;\n    message: AlfaFrensMessage;\n    isBotMessage: boolean;\n}): Memory {\n    return {\n        id: params.message.id as UUID,\n        userId: params.senderId,\n        agentId: params.runtime.agentId,\n        content: {\n            text: params.message.content || \"\",\n            action: params.isBotMessage ? \"ALFAFRENS_SEND_MESSAGE\" : undefined\n        },\n        roomId: params.roomId\n    };\n} ","import { IAgentRuntime, elizaLogger, ModelClass, generateText, stringToUuid, UUID } from \"@elizaos/core\";\nimport type { AlfaFrensConfig, AlfaFrensMessage, AlfaFrensGenerationConfig } from \"../types\";\nimport { createAlfaFrensMemory } from \"../memory\";\nimport { FactValidationManager } from \"./fact-validation\";\nimport {\n    DEFAULT_RESPONSE_TEMPLATE,\n    DEFAULT_POST_TEMPLATE,\n    DEFAULT_EVALUATION_TEMPLATE,\n    getNumericSetting,\n    parseModelClass,\n    processTemplate,\n    evaluateMessage,\n    generatePostContent,\n    generateResponse as generateResponseUtil\n} from \"./utils\";\nimport { AlfaFrensTaskManager } from \"./tasks\";\n\nexport interface AlfaFrensClient {\n    config: AlfaFrensConfig;\n    getMessages(params: {\n        roomId: string;\n        since?: number;\n        until?: number;\n        includeReactions?: boolean;\n        includeReplies?: boolean;\n    }): Promise<AlfaFrensMessage[]>;\n    createPost(params: {\n        content: string;\n        roomId: string;\n    }): Promise<{ memory: any; message: AlfaFrensMessage }[]>;\n    sendMessage(params: {\n        content: string;\n        roomId: string;\n        inReplyTo?: string;\n    }): Promise<{ memory: any; message: AlfaFrensMessage }[]>;\n}\n\n/**\n * options for configuring the AI interaction manager\n */\nexport interface AlfaFrensAIInteractionOptions {\n    /** template for evaluating whether to respond to a message */\n    evaluationTemplate?: string;\n    /** template for generating responses to messages */\n    responseTemplate?: string;\n    /** model class to use for generation */\n    modelClass?: ModelClass;\n    /** interval between checking for new messages in seconds */\n    intervalSeconds?: number;\n    /** maximum number of messages to keep in history */\n    maxHistoryLength?: number;\n    /** template for generating post content */\n    postTemplate?: string;\n    /** pre-loaded generation configuration */\n    generationConfig?: AlfaFrensGenerationConfig;\n}\n\n/**\n * helper function to get model class from settings with proper fallback\n */\nfunction getModelClass(runtime: IAgentRuntime, settingName: string, fallbackSetting = \"ALFAFRENS_MODEL_CLASS\"): ModelClass | undefined {\n    return parseModelClass(runtime.getSetting(settingName)) ||\n        parseModelClass(runtime.getSetting(fallbackSetting));\n}\n\n/**\n * get config for AI operations with consistent fallbacks\n */\nfunction getConfig<T extends 'evaluation' | 'response' | 'post'>(\n    options: AlfaFrensAIInteractionOptions,\n    runtime: IAgentRuntime,\n    type: T\n): { template: string, modelClass: ModelClass | undefined } {\n    const defaultTemplates = {\n        'evaluation': DEFAULT_EVALUATION_TEMPLATE,\n        'response': DEFAULT_RESPONSE_TEMPLATE,\n        'post': DEFAULT_POST_TEMPLATE\n    };\n\n    const settingNames = {\n        'evaluation': 'ALFAFRENS_EVALUATION_MODEL_CLASS',\n        'response': 'ALFAFRENS_RESPONSE_MODEL_CLASS',\n        'post': 'ALFAFRENS_POST_MODEL_CLASS'\n    };\n\n    return {\n        template: options[`${type}Template`] || defaultTemplates[type],\n        modelClass: options.modelClass || getModelClass(runtime, settingNames[type])\n    };\n}\n\n/**\n * an extension for AI-powered interactions with AlfaFrens messages\n */\nexport class AlfaFrensAIInteraction {\n    private runtime: IAgentRuntime;\n    private client: AlfaFrensClient;\n    private factValidationManager: FactValidationManager;\n    private taskManager: AlfaFrensTaskManager;\n    private options: {\n        evaluationTemplate?: string;\n        responseTemplate?: string;\n        postTemplate?: string;\n        modelClass?: ModelClass;\n        intervalSeconds?: number;\n        maxHistoryLength?: number;\n        generationConfig?: AlfaFrensGenerationConfig;\n    };\n    private isRunning: boolean = false;\n    private messageHistory: AlfaFrensMessage[] = [];\n    private lastProcessedTime: number = Date.now();\n    private pollIntervalId: NodeJS.Timeout | null = null;\n    private postIntervalId: NodeJS.Timeout | null = null;\n    // Track our sent message IDs\n    private sentMessageIds: Set<string> = new Set();\n\n    /**\n     * creates a new AI interaction manager\n     * @param client the AlfaFrens client manager\n     * @param runtime the agent runtime\n     * @param options optional configuration options\n     */\n    constructor(client: AlfaFrensClient, runtime: IAgentRuntime, options: AlfaFrensAIInteractionOptions = {}) {\n        elizaLogger.debug(\"[AlfaFrensAIInteraction] constructor called\");\n        this.client = client;\n        this.runtime = runtime;\n        this.options = options;\n        this.factValidationManager = new FactValidationManager(runtime);\n        this.taskManager = new AlfaFrensTaskManager(runtime);\n    }\n\n    /**\n     * start the automated interaction service\n     * @param intervalSeconds optional override for seconds between checking (default from options or 30)\n     */\n    async start(intervalSeconds?: number): Promise<void> {\n        elizaLogger.debug(\"[AlfaFrensAIInteraction] start called with intervalSeconds:\", intervalSeconds);\n        if (this.isRunning) {\n            elizaLogger.debug(\"[AlfaFrensAIInteraction] already running, returning early\");\n            return;\n        }\n        this.isRunning = true;\n\n        const interval = intervalSeconds ||\n            this.options.intervalSeconds ||\n            getNumericSetting(this.runtime, \"ALFAFRENS_POLL_INTERVAL_SECONDS\", 30);\n\n        elizaLogger.debug(\"[AlfaFrensAIInteraction] using interval:\", interval, \"seconds\");\n        elizaLogger.info(`[AlfaFrensAIInteraction] Starting AI interaction manager with interval: ${interval}s`);\n\n        // Setup direct polling interval\n        this.pollIntervalId = setInterval(() => {\n            elizaLogger.debug(\"[AlfaFrensAIInteraction] Poll interval triggered\");\n            this.processMessages().catch(err => {\n                elizaLogger.error(\"[AlfaFrensAIInteraction] Error processing messages:\", err);\n            });\n        }, interval * 1000);\n\n        // Run initial message processing\n        await this.processMessages().catch(err => {\n            elizaLogger.error(\"[AlfaFrensAIInteraction] Error in initial message processing:\", err);\n        });\n\n        // Setup posting if enabled\n        if (this.client.config.enablePost) {\n            const postInterval = Math.floor(\n                Math.random() * (this.client.config.postIntervalMax - this.client.config.postIntervalMin) +\n                this.client.config.postIntervalMin\n            );\n\n            elizaLogger.debug(`[AlfaFrensAIInteraction] Setting up post interval: ${postInterval}s`);\n            this.postIntervalId = setInterval(() => {\n                elizaLogger.debug(\"[AlfaFrensAIInteraction] Post interval triggered\");\n                this.createPost().catch(err => {\n                    elizaLogger.error(\"[AlfaFrensAIInteraction] Error creating post:\", err);\n                });\n            }, postInterval * 1000);\n        }\n\n        elizaLogger.info(\"[AlfaFrensAIInteraction] Started successfully\");\n    }\n\n    /**\n     * stop the automated interaction service\n     */\n    async stop(): Promise<void> {\n        if (!this.isRunning) {\n            elizaLogger.debug(\"[AlfaFrensAIInteraction] already stopped\");\n            return;\n        }\n\n        elizaLogger.info(\"[AlfaFrensAIInteraction] Stopping AI interaction manager\");\n        this.isRunning = false;\n\n        // Clear intervals\n        if (this.pollIntervalId) {\n            clearInterval(this.pollIntervalId);\n            this.pollIntervalId = null;\n        }\n\n        if (this.postIntervalId) {\n            clearInterval(this.postIntervalId);\n            this.postIntervalId = null;\n        }\n    }\n\n    /**\n     * process messages from the API\n     */\n    private async processMessages(): Promise<void> {\n        elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Starting ${Date.now()}`);\n        elizaLogger.debug(`Client polling state: isRunning=${this.isRunning}`);\n\n        try {\n            if (!this.isRunning) {\n                elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Not running, skipping message processing`);\n                return;\n            }\n\n            // fetch new messages from the API with room ID\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Current lastProcessedTime: ${this.lastProcessedTime}`);\n            const startTimestamp = Date.now();\n\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Fetching messages since ${this.lastProcessedTime}`);\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] About to call client.getMessages for room ${this.client.config.channelId}`);\n\n            const messages = await this.client.getMessages({\n                roomId: this.client.config.channelId,\n                since: this.lastProcessedTime,\n                includeReactions: false,\n                includeReplies: false\n            });\n\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Retrieved ${messages.length} messages`);\n\n            if (messages.length === 0) {\n                elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] No new messages to process`);\n                return;\n            }\n\n            // update our history with the new messages\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Updating message history, current length: ${this.messageHistory.length}`);\n            this.messageHistory = this.messageHistory\n                .concat(messages)\n                // keep the last 50 messages\n                .slice(-50);\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] New history length: ${this.messageHistory.length}`);\n\n            // update the last processed time\n            const lastTimestamp = messages[messages.length - 1].timestamp;\n            this.lastProcessedTime = new Date(lastTimestamp).getTime() + 1; // add 1ms to avoid duplicates\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] New lastProcessedTime: ${this.lastProcessedTime}`);\n\n            // process the messages in batches (handle 10 at a time)\n            const batchSize = 10;\n            const messageBatches = [];\n\n            for (let i = 0; i < messages.length; i += batchSize) {\n                messageBatches.push(messages.slice(i, i + batchSize));\n            }\n\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Processing ${messageBatches.length} message batches`);\n\n            for (const batch of messageBatches) {\n                elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Processing batch of ${batch.length} messages`);\n                try {\n                    await this.processMessageBatch(batch);\n                } catch (batchError) {\n                    elizaLogger.error(`[AlfaFrensAIInteraction.processMessages] Error processing batch: ${batchError instanceof Error ? batchError.message : String(batchError)}`);\n                }\n            }\n\n            const endTimestamp = Date.now();\n            const duration = endTimestamp - startTimestamp;\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Processing completed in ${duration}ms`);\n        } catch (error) {\n            elizaLogger.error(`[AlfaFrensAIInteraction.processMessages] ERROR: ${error instanceof Error ? error.message : String(error)}`);\n            if (error instanceof Error && error.stack) {\n                elizaLogger.error(`[AlfaFrensAIInteraction.processMessages] Stack: ${error.stack}`);\n            }\n        } finally {\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessages] Completed ${Date.now()}`);\n        }\n    }\n\n    /**\n     * Process a single message batch\n     */\n    private async processMessageBatch(messages: AlfaFrensMessage[]): Promise<void> {\n        for (const message of messages) {\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Processing message: ${message.id}`);\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Message sender: ${message.senderId}, our userId: ${this.client.config.userId}`);\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Message username: ${message.senderUsername}, our username: ${this.client.config.username}`);\n\n            // Skip our own messages by checking against our tracked message IDs\n            if (this.sentMessageIds.has(message.id)) {\n                elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Skipping our own message (ID match)`);\n                continue;\n            }\n\n            // Skip messages from our configured user ID if it matches\n            if (message.senderId === this.client.config.userId) {\n                elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Skipping message from our user ID`);\n                continue;\n            }\n\n            // Check username with normalization (strip @ symbol)\n            const normalizedMessageUsername = message.senderUsername?.replace('@', '') || '';\n            const normalizedConfigUsername = this.client.config.username?.replace('@', '') || '';\n\n            if (normalizedMessageUsername && normalizedConfigUsername &&\n                normalizedMessageUsername === normalizedConfigUsername) {\n                elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Skipping message from our normalized username: ${message.senderUsername} matches ${this.client.config.username}`);\n                continue;\n            }\n\n            // Create memory for message history tracking\n            const memory = createAlfaFrensMemory({\n                roomId: stringToUuid(this.client.config.channelId),\n                senderId: stringToUuid(message.senderId || \"user\"),\n                runtime: this.runtime,\n                message,\n                isBotMessage: false\n            });\n\n            // Store message in memory manager\n            try {\n                await this.runtime.messageManager.createMemory(memory);\n                elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Stored message in memory manager`);\n            } catch (error) {\n                elizaLogger.error(`[AlfaFrensAIInteraction.processMessageBatch] Failed to store message in memory:`, error);\n            }\n\n            // Evaluate if we should respond to this message\n            const config = getConfig(this.options, this.runtime, 'evaluation');\n            elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Evaluating message with template length ${config.template.length}`);\n\n            try {\n                const shouldRespond = await evaluateMessage(this.runtime, message, {\n                    template: config.template,\n                    modelClass: config.modelClass\n                });\n\n                if (!shouldRespond) {\n                    elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Decided not to respond to message`);\n                    continue;\n                }\n\n                // Generate a response using knowledge integration\n                elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Generating response to message`);\n                const responseConfig = getConfig(this.options, this.runtime, 'response');\n\n                const response = await generateResponseUtil(\n                    this.runtime,\n                    this.client,  // Pass the client for knowledge access\n                    message.content || \"\",\n                    this.messageHistory.slice(-10),  // Use last 10 messages for context\n                    responseConfig.template,\n                    responseConfig.modelClass\n                );\n\n                // Send the response through API\n                elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Sending response: ${response.substring(0, 50)}...`);\n\n                try {\n                    const result = await this.client.sendMessage({\n                        content: response,\n                        roomId: this.client.config.channelId,\n                        inReplyTo: message.id\n                    });\n\n                    // Track the message ID we just sent\n                    if (result && result.length > 0 && result[0].message && result[0].message.id) {\n                        this.sentMessageIds.add(result[0].message.id);\n                        elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Tracked our sent message ID: ${result[0].message.id}`);\n                    }\n\n                    elizaLogger.debug(`[AlfaFrensAIInteraction.processMessageBatch] Response sent successfully`);\n                } catch (error) {\n                    elizaLogger.error(`[AlfaFrensAIInteraction.processMessageBatch] Failed to send response:`, error);\n                }\n            } catch (error) {\n                elizaLogger.error(`[AlfaFrensAIInteraction.processMessageBatch] Error processing message:`, error);\n            }\n        }\n    }\n\n    /**\n     * format the conversation history for context\n     * @returns formatted conversation history\n     */\n    private formatConversationHistory(): string {\n        if (this.messageHistory.length === 0) {\n            return \"No previous messages.\";\n        }\n\n        // get number of history messages from character file or default to 5\n        const historyCount = getNumericSetting(this.runtime, \"ALFAFRENS_HISTORY_COUNT\", 5);\n\n        // get the recent messages\n        const recentMessages = this.messageHistory.slice(-historyCount);\n\n        return recentMessages.map(msg => {\n            const role = msg.senderId === this.client.config.userId ?\n                \"ASSISTANT\" :\n                `USER (${msg.senderUsername})`;\n            return `${role}: ${msg.content}`;\n        }).join(\"\\n\\n\");\n    }\n\n    /**\n     * generate and create a new post\n     * @param customContent optional custom content to post\n     * @returns the created post\n     */\n    async createPost(customContent?: string): Promise<any> {\n        try {\n            elizaLogger.info(\"[AlfaFrensAIInteraction] Starting post creation\");\n            const content = customContent || await this.generatePostContent();\n            elizaLogger.info(\"[AlfaFrensAIInteraction] Generated post content:\", {\n                contentLength: content.length,\n                content: content\n            });\n\n            // format content\n            const formattedContent = content;\n\n            const result = await this.client.createPost({\n                content: formattedContent,\n                roomId: this.client.config.channelId\n            });\n\n            // Track the post ID we just created\n            if (result && result.length > 0 && result[0].message && result[0].message.id) {\n                this.sentMessageIds.add(result[0].message.id);\n                elizaLogger.debug(`[AlfaFrensAIInteraction] Tracked our sent post ID: ${result[0].message.id}`);\n            }\n\n            elizaLogger.info(\"[AlfaFrensAIInteraction] Post created successfully:\", {\n                messageId: result[0].message.id,\n                timestamp: result[0].message.timestamp\n            });\n            return result;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrensAIInteraction] Failed to create post:\", error);\n            throw error;\n        }\n    }\n\n    /**\n     * generate content for a post using the AI\n     * @param customTemplate optional override template for this specific generation\n     * @returns generated post content\n     */\n    private async generatePostContent(customTemplate?: string): Promise<string> {\n        const config = customTemplate ?\n            { template: customTemplate, modelClass: getModelClass(this.runtime, \"ALFAFRENS_POST_MODEL_CLASS\") } :\n            getConfig(this.options, this.runtime, 'post');\n\n        return generatePostContent(this.runtime, config);\n    }\n\n    private async extractFacts(content: string): Promise<string[]> {\n        const prompt = `Extract factual statements from this text. Return them as a JSON array of strings.\n        Only include clear, factual statements, not opinions or subjective content.\n        \n        Text: \"${content}\"\n        \n        Example response:\n        [\"John lives in New York\", \"The company was founded in 2020\"]\n        `;\n\n        try {\n            const result = await generateText({\n                runtime: this.runtime,\n                context: prompt,\n                modelClass: ModelClass.SMALL,\n            });\n\n            const facts = JSON.parse(result);\n            if (!Array.isArray(facts)) {\n                elizaLogger.error(\"[AlfaFrensAIInteraction] Invalid fact extraction result:\", result);\n                return [];\n            }\n            return facts;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrensAIInteraction] Failed to extract facts:\", error);\n            return [];\n        }\n    }\n}","import { IAgentRuntime, Memory, elizaLogger, UUID, State } from \"@elizaos/core\";\nimport { AlfaFrensMessage } from \"../types\";\nimport { FactValidationManager } from \"./fact-validation\";\nimport { v4 as uuidv4 } from \"uuid\";\n\n// Import Task and TaskWorker types from ElizaOS core\ninterface Task {\n    id?: UUID;\n    name: string;\n    description: string;\n    roomId?: UUID;\n    worldId?: UUID;\n    tags: string[];\n    metadata?: {\n        updateInterval?: number;\n        options?: {\n            name: string;\n            description: string;\n        }[];\n        [key: string]: unknown;\n    };\n}\n\ninterface TaskWorker {\n    name: string;\n    execute: (\n        runtime: IAgentRuntime,\n        options: { [key: string]: unknown },\n        task: Task\n    ) => Promise<void>;\n    validate?: (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State\n    ) => Promise<boolean>;\n}\n\ninterface FactValidationTask extends Task {\n    name: \"FACT_VALIDATION\";\n    metadata: {\n        fact: string;\n        source: string;\n        requiresConfirmation?: boolean;\n        scheduledFor?: number;\n        validation?: {\n            confidence: number;\n            contradictions: string[];\n        };\n    };\n}\n\ninterface AIInteractionTask extends Task {\n    name: \"AI_INTERACTION\";\n    metadata: {\n        type: \"POLL\" | \"POST\" | \"RESPONSE\";\n        interval: number;\n        lastProcessed: number;\n        messageId?: string;\n    };\n}\n\n/**\n * Simple task definition\n */\nexport interface SimpleTask {\n    id: string;\n    name: string;\n    type: \"POLL\" | \"POST\" | \"RESPONSE\";\n    interval: number;\n    lastRun: number;\n    handler: () => Promise<void>;\n}\n\n/**\n * Simplified task manager that doesn't rely on ElizaOS runtime task methods\n */\nexport class AlfaFrensTaskManager {\n    private runtime: IAgentRuntime;\n    private factValidationManager: FactValidationManager;\n    private tasks: Map<string, SimpleTask> = new Map();\n    private intervals: Map<string, NodeJS.Timeout> = new Map();\n    private isRunning: boolean = false;\n\n    constructor(runtime: IAgentRuntime) {\n        this.runtime = runtime;\n        this.factValidationManager = new FactValidationManager(runtime);\n        elizaLogger.debug(\"[AlfaFrensTaskManager] Initialized\");\n    }\n\n    private registerTaskWorkers(): void {\n        // Fact Validation Worker\n        (this.runtime as any).registerTaskWorker({\n            name: \"FACT_VALIDATION\",\n            validate: async (runtime, message, state) => {\n                // Only validate facts from non-bot users\n                return message.userId !== runtime.agentId;\n            },\n            execute: async (runtime, options, task) => {\n                const factTask = task as FactValidationTask;\n                const validation = await this.factValidationManager.validateFact(\n                    factTask.metadata.fact,\n                    {\n                        id: task.id,\n                        timestamp: new Date().toISOString(),\n                        senderId: factTask.metadata.source,\n                        senderUsername: factTask.metadata.source,\n                        content: factTask.metadata.fact\n                    }\n                );\n\n                if (validation.confidence >= 0.7) {\n                    await this.factValidationManager.storeFact(\n                        factTask.metadata.fact,\n                        validation\n                    );\n                }\n\n                // Delete the task after completion\n                await (runtime as any).deleteTask(task.id);\n            }\n        });\n\n        // AI Interaction Worker\n        (this.runtime as any).registerTaskWorker({\n            name: \"AI_INTERACTION\",\n            validate: async (runtime, message, state) => {\n                const task = await (runtime as any).getTask(message.id);\n                if (!task) return false;\n\n                const interactionTask = task as AIInteractionTask;\n                const now = Date.now();\n                return now - interactionTask.metadata.lastProcessed >= interactionTask.metadata.interval;\n            },\n            execute: async (runtime, options, task) => {\n                const interactionTask = task as AIInteractionTask;\n\n                switch (interactionTask.metadata.type) {\n                    case \"POLL\":\n                        // Handle message polling\n                        break;\n                    case \"POST\":\n                        // Handle content posting\n                        break;\n                    case \"RESPONSE\":\n                        // Handle response generation\n                        break;\n                }\n\n                // Update last processed time\n                await (runtime as any).updateTask(task.id, {\n                    metadata: {\n                        ...interactionTask.metadata,\n                        lastProcessed: Date.now()\n                    }\n                });\n            }\n        });\n    }\n\n    async createFactValidationTask(\n        fact: string,\n        source: string,\n        options: {\n            deferred?: boolean;\n            requiresConfirmation?: boolean;\n        } = {}\n    ): Promise<FactValidationTask> {\n        const task: FactValidationTask = {\n            name: \"FACT_VALIDATION\",\n            description: `Validate fact: ${fact}`,\n            tags: [\"fact-validation\"],\n            metadata: {\n                fact,\n                source,\n                requiresConfirmation: options.requiresConfirmation,\n                scheduledFor: options.deferred ? Date.now() + 3600000 : undefined // 1 hour delay if deferred\n            }\n        };\n\n        return (this.runtime as any).createTask(task) as Promise<FactValidationTask>;\n    }\n\n    /**\n     * Create a task for AI interaction\n     */\n    async createAIInteractionTask(\n        type: \"POLL\" | \"POST\" | \"RESPONSE\",\n        interval: number,\n        handler?: () => Promise<void>\n    ): Promise<SimpleTask> {\n        const id = uuidv4();\n        const task: SimpleTask = {\n            id,\n            name: `AI_INTERACTION_${type}`,\n            type,\n            interval,\n            lastRun: Date.now(),\n            handler: handler || (() => Promise.resolve())\n        };\n\n        this.tasks.set(id, task);\n        elizaLogger.debug(`[AlfaFrensTaskManager] Created ${type} task with interval ${interval}ms`);\n\n        // Set up interval if running\n        if (this.isRunning) {\n            this.startTaskInterval(task);\n        }\n\n        return task;\n    }\n\n    /**\n     * Start running task intervals\n     */\n    async start(): Promise<void> {\n        if (this.isRunning) {\n            return;\n        }\n\n        this.isRunning = true;\n        elizaLogger.debug(\"[AlfaFrensTaskManager] Starting task manager\");\n\n        // Start all task intervals\n        for (const task of this.tasks.values()) {\n            this.startTaskInterval(task);\n        }\n    }\n\n    /**\n     * Stop all task intervals\n     */\n    async stop(): Promise<void> {\n        if (!this.isRunning) {\n            return;\n        }\n\n        this.isRunning = false;\n        elizaLogger.debug(\"[AlfaFrensTaskManager] Stopping task manager\");\n\n        // Clear all intervals\n        for (const [id, interval] of this.intervals.entries()) {\n            clearInterval(interval);\n            this.intervals.delete(id);\n        }\n    }\n\n    /**\n     * Process all tasks immediately\n     */\n    async processTasks(): Promise<void> {\n        elizaLogger.debug(`[AlfaFrensTaskManager] Processing ${this.tasks.size} tasks`);\n\n        for (const task of this.tasks.values()) {\n            try {\n                await task.handler();\n                task.lastRun = Date.now();\n            } catch (error) {\n                elizaLogger.error(`[AlfaFrensTaskManager] Error processing task ${task.name}:`, error);\n            }\n        }\n    }\n\n    /**\n     * Start interval for a task\n     */\n    private startTaskInterval(task: SimpleTask): void {\n        // Clear existing interval if any\n        if (this.intervals.has(task.id)) {\n            clearInterval(this.intervals.get(task.id)!);\n        }\n\n        // Set new interval\n        const interval = setInterval(async () => {\n            try {\n                await task.handler();\n                task.lastRun = Date.now();\n            } catch (error) {\n                elizaLogger.error(`[AlfaFrensTaskManager] Error in task ${task.name}:`, error);\n            }\n        }, task.interval);\n\n        this.intervals.set(task.id, interval);\n        elizaLogger.debug(`[AlfaFrensTaskManager] Started interval for task ${task.name}`);\n    }\n} ","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","import { randomFillSync } from 'crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n","import { randomUUID } from 'crypto';\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import { AlfaFrensClientInterface } from \"./alfafrens-client\";\nimport { elizaLogger, Plugin } from \"@elizaos/core\";\nimport { actions as alfaFrensActions } from \"./actions\";\n\nelizaLogger.debug(\"[AlfaFrensPlugin] Initializing plugin\");\n\n/**\n * plugin for AlfaFrens client\n */\nexport const AlfaFrensPlugin: Plugin = {\n    name: \"alfafrens\",\n    description: \"AlfaFrens client plugin\",\n    clients: [AlfaFrensClientInterface],\n    actions: alfaFrensActions\n};\n\nelizaLogger.debug(\"[AlfaFrensPlugin] Plugin initialized\");\n\nexport default AlfaFrensPlugin; ","import { IAgentRuntime, elizaLogger, Action, Memory } from \"@elizaos/core\";\nimport { AlfaFrensManager } from \"./alfafrens-client\";\nimport type { AlfaFrensMemoryContent } from \"./types\";\n\n/**\n * sends a message to the AlfaFrens channel\n */\nexport const sendAlfaFrensMessageAction: Action = {\n    name: \"ALFAFRENS_SEND_MESSAGE\",\n    description: \"sends a message to the AlfaFrens channel\",\n    similes: [\"send\", \"message\", \"chat\", \"respond\"],\n    examples: [[\n        {\n            user: \"user\",\n            content: {\n                text: \"send a message to AlfaFrens\",\n                action: \"ALFAFRENS_SEND_MESSAGE\"\n            }\n        }\n    ]],\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensMemoryContent;\n        if (!content?.text) {\n            elizaLogger.error(\"[AlfaFrens] message content is missing\");\n            return false;\n        }\n        return true;\n    },\n    handler: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensMemoryContent;\n        const client = runtime.clients.find(c => c.constructor.name === \"AlfaFrensManager\") as AlfaFrensManager;\n        if (!client) {\n            elizaLogger.error(\"[AlfaFrens] client not found\");\n            return false;\n        }\n\n        try {\n            await client.sendMessage({\n                content: content.text,\n                roomId: client.config.channelId\n            });\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrens] failed to send message:\", error);\n            return false;\n        }\n    }\n};\n\n/**\n * creates a new post in the AlfaFrens channel\n */\nexport const createAlfaFrensPostAction: Action = {\n    name: \"ALFAFRENS_CREATE_POST\",\n    description: \"creates a new post in the AlfaFrens channel\",\n    similes: [\"post\", \"share\", \"announce\", \"publish\"],\n    examples: [[\n        {\n            user: \"user\",\n            content: {\n                text: \"create a post in AlfaFrens\",\n                action: \"ALFAFRENS_CREATE_POST\"\n            }\n        }\n    ]],\n    validate: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensMemoryContent;\n        if (!content?.text) {\n            elizaLogger.error(\"[AlfaFrens] post content is missing\");\n            return false;\n        }\n        return true;\n    },\n    handler: async (runtime: IAgentRuntime, message: Memory) => {\n        const content = message.content as AlfaFrensMemoryContent;\n        const client = runtime.clients.find(c => c.constructor.name === \"AlfaFrensManager\") as AlfaFrensManager;\n        if (!client) {\n            elizaLogger.error(\"[AlfaFrens] client not found\");\n            return false;\n        }\n\n        try {\n            await client.createPost({\n                content: content.text,\n                roomId: client.config.channelId\n            });\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrens] failed to create post:\", error);\n            return false;\n        }\n    }\n};\n\n// export all actions\nexport const actions = [\n    sendAlfaFrensMessageAction,\n    createAlfaFrensPostAction\n]; ","/**\n * AI extensions for the AlfaFrens client\n * \n * These extensions are optional and can be used to add AI capabilities\n * to the AlfaFrens client.\n */\n\nimport { AlfaFrensAIPost } from \"./ai-post\";\nimport { AlfaFrensAIInteraction } from \"./ai-interaction\";\nimport { createAlfaFrensActions, registerAlfaFrensActions } from \"./actions\";\nimport * as utils from \"./utils\";\n\nexport {\n    AlfaFrensAIPost,\n    AlfaFrensAIInteraction,\n    createAlfaFrensActions,\n    registerAlfaFrensActions,\n    utils\n}; ","import { IAgentRuntime, elizaLogger, ModelClass } from \"@elizaos/core\";\nimport { AlfaFrensManager } from \"../alfafrens-client\";\nimport {\n    DEFAULT_POST_TEMPLATE,\n    generatePostContent,\n    getNumericSetting,\n    parseModelClass\n} from \"./utils\";\nimport type { AlfaFrensGenerationConfig } from \"../types\";\nimport { AlfaFrensTaskManager } from \"./tasks\";\n\n/**\n * options for configuring the AI post generator\n */\nexport interface AlfaFrensAIPostOptions {\n    /** template for generating post content */\n    postTemplate?: string;\n    /** model class to use for generation */\n    modelClass?: ModelClass;\n    /** interval between posts in seconds */\n    intervalSeconds?: number;\n}\n\n/**\n * an extension for generating AI-powered posts for AlfaFrens\n */\nexport class AlfaFrensAIPost {\n    private runtime: IAgentRuntime;\n    private client: AlfaFrensManager;\n    private interval?: NodeJS.Timeout;\n    private isRunning: boolean = false;\n    private options: AlfaFrensAIPostOptions;\n    private lastPostTime: number = 0;\n    private taskManager: AlfaFrensTaskManager;\n\n    /**\n     * creates a new AI post generator\n     * @param client the AlfaFrens client manager\n     * @param runtime the agent runtime\n     * @param options optional configuration options\n     */\n    constructor(\n        client: AlfaFrensManager,\n        runtime: IAgentRuntime,\n        options: AlfaFrensAIPostOptions = {}\n    ) {\n        this.client = client;\n        this.runtime = runtime;\n        this.options = options;\n        this.taskManager = new AlfaFrensTaskManager(runtime);\n    }\n\n    /**\n     * start the automated posting service\n     * @param intervalSeconds optional override for seconds between posts (default from options or 3600)\n     */\n    async start(intervalSeconds?: number): Promise<void> {\n        if (this.isRunning) {\n            elizaLogger.debug(\"[AlfaFrensAIPost] already running, returning early\");\n            return;\n        }\n        this.isRunning = true;\n\n        const interval = intervalSeconds ||\n            this.options.intervalSeconds ||\n            getNumericSetting(this.runtime, \"ALFAFRENS_POST_INTERVAL_SECONDS\", 3600);\n\n        elizaLogger.debug(\"[AlfaFrensAIPost] using interval:\", interval, \"seconds\");\n        elizaLogger.info(`[AlfaFrensAIPost] Starting AI post generator with interval: ${interval}s`);\n\n        // create posting task\n        await this.taskManager.createAIInteractionTask(\"POST\", interval * 1000);\n    }\n\n    /**\n     * stop the automated posting service\n     */\n    async stop(): Promise<void> {\n        if (!this.isRunning) {\n            elizaLogger.debug(\"[AlfaFrensAIPost] already stopped\");\n            return;\n        }\n\n        elizaLogger.info(\"[AlfaFrensAIPost] Stopping AI post generator\");\n        this.isRunning = false;\n\n        // process any remaining tasks\n        await this.taskManager.processTasks();\n    }\n\n    /**\n     * generate and create a new post\n     * @param customContent optional custom content to post\n     * @returns the created post\n     */\n    private async createPost(customContent?: string): Promise<any> {\n        try {\n            elizaLogger.info(\"[AlfaFrensAIPost] Starting post creation\");\n            const content = customContent || await this.generatePostContent();\n            elizaLogger.info(\"[AlfaFrensAIPost] Generated post content:\", {\n                contentLength: content.length,\n                content: content\n            });\n\n            // format content\n            const formattedContent = content;\n\n            const result = await this.client.createPost({\n                content: formattedContent,\n                roomId: this.client.config.channelId\n            });\n\n            elizaLogger.info(\"[AlfaFrensAIPost] Post created successfully:\", {\n                messageId: result[0].message.id,\n                timestamp: result[0].message.timestamp\n            });\n            return result;\n        } catch (error) {\n            elizaLogger.error(\"[AlfaFrensAIPost] Failed to create post:\", error);\n            throw error;\n        }\n    }\n\n    /**\n     * generate content for a post using the AI\n     * @param customTemplate optional override template for this specific generation\n     * @returns generated post content\n     */\n    private async generatePostContent(customTemplate?: string): Promise<string> {\n        const config: AlfaFrensGenerationConfig['post'] = {\n            template: customTemplate || this.options.postTemplate || DEFAULT_POST_TEMPLATE,\n            modelClass: this.options.modelClass || parseModelClass(this.runtime.getSetting(\"ALFAFRENS_POST_MODEL_CLASS\"))\n        };\n\n        return generatePostContent(this.runtime, config);\n    }\n} ","import { Client } from \"@elizaos/core\";\nimport { AlfaFrensClientInterface } from \"./alfafrens-client\";\nimport plugin from \"./plugin\";\n\n// Export the plugin as default\nexport default plugin;\n\n// Export types and interfaces\nexport type { AlfaFrensMessage, AlfaFrensSendMessageResponse, GetMessagesOptions } from \"./types\";\nexport type { AlfaFrensConfig } from \"./environment\";\n\n// Re-export the API client\nexport { AlfaFrensApi } from \"./api\";\n\n// Re-export extensions (optional AI capabilities)\nexport * as Extensions from \"./extensions\";\n\n// Export the client interface\nexport const AlfaFrensClient: Client = AlfaFrensClientInterface;\n\n// Export all client interfaces\nexport { AlfaFrensClientInterface };\n\n// Export types\nexport * from \"./types\";\n\n// Export memory functions\nexport { createAlfaFrensMemory } from \"./memory\";\n\n// Export actions\nexport { actions as alfaFrensActions } from \"./actions\"; "],"mappings":"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","names":["ModelClass","loadAlfaFrensConfig","runtime","defaultModelClass","parseModelClass","modelClass","init_config","__esmMin","elizaLogger","stringToUuid","generateText","ModelClass","FactValidationManager","init_fact_validation","__esmMin","runtime","content","prompt","result","jsonMatch","jsonStr","facts","validFacts","fact","parseError","error","potentialFacts","sentence","isQuestion","hasOpinionWords","hasFactSignals","message","existingFacts","contradictions","confidence","relationships","memory","existingFact","contradiction","fact1","fact2","analysis","avgContradictionConfidence","acc","text1","text2","words1","words2","intersection","x","union","validation","utils_exports","__export","DEFAULT_EVALUATION_TEMPLATE","DEFAULT_POST_TEMPLATE","DEFAULT_RESPONSE_TEMPLATE","evaluateMessage","generatePostContent","generateResponse","getNumericSetting","parseModelClass","processTemplate","elizaLogger","generateText","ModelClass","ServiceType","template","runtime","additionalData","character","result","key","value","subKey","subValue","modelClass","defaultValue","parsed","formatConversationHistory","messages","msg","generateLLMResponse","context","logPrefix","traceId","id","timeoutPromise","_","reject","llmPromise","error","errorMessage","config","content","client","message","messageHistory","webSearchResults","webSearchService","searchResults","i","knowledgeContext","knowledgeResults","r","formattedHistory","prompt","rawResponse","factValidationManager","FactValidationManager","extractedFacts","dummyMessage","requiresCorrection","factValidationResults","fact","validation","correctionContext","revisedPrompt","correctedResponse","init_utils","__esmMin","init_fact_validation","actions_exports","__export","createAlfaFrensActions","registerAlfaFrensActions","elizaLogger","getMessageHistory","client","message","maxHistory","replyTo","messages","thread","currentMessage","m","error","runtime","config","loadAlfaFrensConfig","_runtime","_message","content","generatePostContent","history","responseContent","generateResponse","actions","action","init_actions","__esmMin","init_utils","init_config","elizaLogger","stringToUuid","elizaLogger","AlfaFrensApi","apiKey","channelId","baseUrl","path","options","response","errorText","data","url","includeValues","error","content","replyToPostId","replyTo","payload","init_config","createAlfaFrensMemory","params","elizaLogger","ModelClass","generateText","stringToUuid","init_fact_validation","init_utils","init_fact_validation","elizaLogger","byteToHex","i","unsafeStringify","arr","offset","randomFillSync","rnds8Pool","poolPtr","rng","randomUUID","native_default","v4","options","buf","offset","native_default","rnds","rng","i","unsafeStringify","v4_default","AlfaFrensTaskManager","runtime","FactValidationManager","elizaLogger","message","state","options","task","factTask","validation","interactionTask","fact","source","type","interval","handler","id","v4_default","error","getModelClass","runtime","settingName","fallbackSetting","parseModelClass","getConfig","options","type","defaultTemplates","DEFAULT_EVALUATION_TEMPLATE","DEFAULT_RESPONSE_TEMPLATE","DEFAULT_POST_TEMPLATE","settingNames","AlfaFrensAIInteraction","client","elizaLogger","FactValidationManager","AlfaFrensTaskManager","intervalSeconds","interval","getNumericSetting","err","postInterval","startTimestamp","messages","lastTimestamp","batchSize","messageBatches","i","batch","batchError","duration","error","message","normalizedMessageUsername","normalizedConfigUsername","memory","createAlfaFrensMemory","stringToUuid","config","evaluateMessage","responseConfig","response","generateResponse","result","historyCount","msg","customContent","content","formattedContent","customTemplate","generatePostContent","prompt","generateText","ModelClass","facts","elizaLogger","AlfaFrensManager","runtime","elizaLogger","AlfaFrensApi","loadAlfaFrensConfig","AlfaFrensAIInteraction","cached","registerAlfaFrensActions","error","params","response","content","roomId","message","createMessageFromResponse","createAlfaFrensMemory","stringToUuid","result","query","limit","results","r","AlfaFrensClientInterface","manager","createMessageFromResponse","response","content","elizaLogger","elizaLogger","sendAlfaFrensMessageAction","runtime","message","content","client","c","error","createAlfaFrensPostAction","actions","elizaLogger","AlfaFrensPlugin","AlfaFrensClientInterface","actions","plugin_default","extensions_exports","__export","AlfaFrensAIInteraction","AlfaFrensAIPost","createAlfaFrensActions","registerAlfaFrensActions","utils_exports","init_utils","elizaLogger","AlfaFrensAIPost","client","runtime","options","AlfaFrensTaskManager","intervalSeconds","elizaLogger","interval","getNumericSetting","customContent","content","formattedContent","result","error","customTemplate","config","DEFAULT_POST_TEMPLATE","parseModelClass","generatePostContent","init_actions","init_utils","index_default","plugin_default","AlfaFrensClient","AlfaFrensClientInterface"]}